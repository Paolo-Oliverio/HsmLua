--[[
	Lua File Generated by Gamely's Crayta-Typescript
	https://github.com/Paolo-Oliverio/Crayta-Typescript
--]] -- Lua Library inline imports
local Hsm = {}
do
  local Model = {}
  Model.__index = Model
  Hsm.Model = Model
  --[[
    Create a new Hsm.Model
  ]]
  function Model.create()
    local o = {}
    o.sDb = {}
    o.depfix = {}
    setmetatable(o, Model)
    return o
  end
  --[[
    Adds new state to Hsm.Model
  ]]
  function Model:add(name, obj, parent)
    local s = {
      name = name,
      obj = obj,
      parent = parent or nil,
      commonAncestorsCache = {}
    }
    if (type(parent) == "string") then
      local p = self.sDb[parent]
      if p then
        s.parent = p
      else
        table.insert(self.depfix, s)
      end
    end
    self.sDb[name] = s
    return s
  end
  --[[
    Overwrite a state in Hsm.Model
  ]]
  function Model:override(name, obj)
    local s = self.sDb[name]
    local old = s.obj
    if s then
      s.obj = obj
    end
    return old
  end
  --[[
    Returns the state with the given name
  ]]
  function Model:getState(name)
    local s = self.sDb[name]
    local _ = not s and print("Warning: State not found: " .. name)
    return s
  end
  function Model:_fixDependencies()
    for _, s in ipairs(self.depfix) do
      local p = self.sDb[s.parent]
      if p then
        s.parent = p
      else
        error("Parent not found: " .. s.parent)
      end
    end
    self.depfix = nil
  end
end
do
  Hsm.M = {}
  local M = Hsm.M
  M.__index = M
  --[[
    Create a new Hsm.M Instance based on Hsm.Model
    @param model : Hsm.Model instance
  ]]
  function M.create(model)
    local o = {}
    --the selected state
    o.current = nil
    --the state being executed at the moment
    o.working = nil
    --the name of the received event
    o.e = ""
    --the data sent with the received event
    o.eData = nil
    o.model = model
    o.__index = o
    if model.depfix then
      model:_fixDependencies()
    end
    setmetatable(o, M)
    return o
  end
  --[[
    Starts the Hsm.M Instance from the given state
    @param initialState : string
  ]]
  function M:start(initialState)
    local s = self.model:getState(initialState)
    self.current = s
    self.working = s
    self:hCall("Enter", nil, s)
    local _ = self.current.obj.Update and self.current.obj:Update(self)
  end
  --[[
    Call hook in the hierarchy from to
    @param from : state can be nil for the root
    @param to : state
  ]]
  function M:hCall(sHook, tFrom, tTo)
    local f
    if tFrom == tTo or tFrom == tTo.parent then
      self.working = tTo
      local _ = tTo.obj[sHook] and tTo.obj[sHook](nil, self)
      return
    end
    if sHook == "Exit" then
      repeat
        if(tTo.obj[sHook]) then
          tTo.obj[sHook](tTo.obj, self)
        end
        tTo = tTo.parent
      until not (tTo ~= nil)
      return
    end
    local tPath = {}
    repeat
      table.insert(tPath, tTo)
      tTo = tTo.parent
    until not (tTo ~= nil)
    local l = #tPath
    for i = l, 1, -1 do
      local s = tPath[i]
      if s.obj[sHook] and s.obj[sHook](s.obj, self) then
        return
      end
    end
  end
  --[[
    Rise Event in the Hsm.M Instance calling Event hook in the hierarchy from current state
    event will be accessed from statemachine with e and data from edata.
    @param name : string
    @param eventData : will get accessed by statemachine.eData
  ]]
  function M:event(name, eventData)
    self.e = name
    self.eData = eventData
    local s = self.current
    repeat
      if s.obj.Event then
        self.working = s
        if s.obj:Event(self) then
          return
        end
      end
      s = s.parent
      if not s then
        break
      end
    until false
    self.eData = nil
    return nil
  end
  --[[
    Find the fist common ancestor bewteen s and target
  ]]
  function M:_findCommonAncestor(s, target)
    repeat
      do
        local t = target
        repeat
          do
            if s == t then
              return t
            end
            t = t.parent
          end
        until not (t ~= nil)
        s = s.parent
      end
    until not (s ~= nil)
    return nil
  end
  --[[
    Default state transition
    @param name : string
    @return : boolean true if transition is successful false if not
  ]]
  function M:switchTo(name)
    local ancestor = self.current.commonAncestorsCache[name]
    local target = self.model:getState(name)
    if not target then
      return false
    end
    if ancestor == nil then
      ancestor = self:_findCommonAncestor(self.current, target)
      self.current.commonAncestorsCache[name] = ancestor
    end
    if(ancestor ~= self.current) then
    self:hCall("Exit", ancestor, self.current)
    end
    self.current = target
    self:hCall("Enter", ancestor, target)
    self.working = target
    return true
  end
  --[[
    Exits, ReInitialize and Updates the current state
  ]]
  function M:restartCurrent()
    local o = self.current.obj
    self.working = self.current
    local _ = o.Exit and o:Exit(self)
    _ = o.Enter and o:Enter(self)
  end
  --[[
    Get the current state
  ]]
  function M:getCurrent()
    return self.current
  end
  --[[
    Exits from all the active states
  ]]
  function M:stop()
    self:hCall("Exit", nil, self.current)
    self.current = nil
  end
  --[[
    Exits from all the active states
  ]]
  function M:update()
    self:hCall("Update", nil, self.current)
  end
  --[[
    Exits from all the active states
  ]] 
  function M:isRunning()
    return self.current ~= nil
  end
  --[[
    Check if the caller is the current state
  ]]
  function M:isCurrent()
    return self.current == self.working
  end
end
return Hsm
