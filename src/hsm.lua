--[[
	Lua File Generated by Gamely's Crayta-Typescript
	https://github.com/Paolo-Oliverio/Crayta-Typescript
--]]

--[[
  Hierarchical State Machine (HSM)
]]
local Hsm = {}
do
  --[[
    Model defining hierarchy of states
  ]]
  local Model = {}
  Model.__index = Model
  Hsm.Model = Model

  --[[
    Constructor of Hsm.Model
  ]]
  Model.Create = function()
    local o = {}
    o.sDb = {}
    o.depfix = {}
    setmetatable(o, Model)
    return o
  end

  --[[
    Adds new state to Hsm.Model
    @param name: name of the state
    @param obj: table that implements state hook functions
    @param parent: parent state table (preferred) or parent name as string
  ]]
  function Model:add(name, obj, parent)
    local s = {
      name = name,
      obj = obj,
      parent = parent or nil,
      commonAncestorsCache = {}
    }

    if (type(parent) == "string") then
      local p = self.sDb[parent]
      if p then
        s.parent = p
      else
        table.insert(self.depfix, s)
      end
    end

    self.sDb[name] = s
    return s
  end

  --[[
    Overwrite a state in Hsm.Model
    @param name: name of the state to override
    @param obj: table that implements state hook functions
  ]]
  function Model:override(name, obj)
    local s = self.sDb[name]
    local old = s.obj
    if s then
      s.obj = obj
    end
    return old
  end

  --[[
    Returns the state with the given name
  ]]
  function Model:get_state(name)
    local s = self.sDb[name]
    local _ = not s and print("Warning: State not found: " .. name)
    return s
  end
  function Model:_fix_dependencies()
    for _, s in ipairs(self.depfix) do
      local p = self.sDb[s.parent]
      if p then
        s.parent = p
      else
        error("Parent not found: " .. s.parent)
      end
    end
    self.depfix = nil
  end
end

do
  --[[
    State Machine class Hsm.M
  ]]
  Hsm.M = {}
  local M = Hsm.M
  M.__index = M

  --[[
    Constructor of Hsm.M Instance based on Hsm.Model
    @param model : Hsm.Model instance
  ]]
  M.Create = function(model)
    local o = {}
    -- the selected state
    o.current = nil
    -- the state being executed at the moment
    o.working = nil
    -- the state we are going to go
    o.next = nil
    -- the name of the received event
    o.e = ""
    -- the data sent with the received event
    o.eData = nil
    o.model = model
    o.__index = o
    if model.depfix then
      model:_fix_dependencies()
    end
    setmetatable(o, M)
    return o
  end

  --[[
    Starts the Hsm.M Instance from the given state
    @param initialState : string
  ]]
  function M:start(initialState)
    print("Starting the state machine")
    local s = self.model:get_state(initialState)
    self.current = s
    self.working = s
    self:h_call("Enter", nil, s)
    local _ = self.current.obj.Update and self.current.obj:Update(self)
  end

  --[[
    Call hook in the hierarchy from 2 to.
    In case of Exit hook it call exit from to to from.
    @param from : state can be nil for the root
    @param to : state
  ]]
  function M:h_call(sHook, tFrom, tTo)
    self.e = sHook    
    -- leaf to root for Exit hook
    if sHook == "Exit" then
      repeat
        if (tTo.obj[sHook]) then
          tTo.obj[sHook](tTo.obj, self)
        end
        tTo = tTo.parent
      until tTo == tFrom
      return
    end
    if tFrom == tTo or tFrom == tTo.parent then
      self.working = tTo
      local _ = tTo.obj[sHook] and tTo.obj[sHook](nil, self)
      if (self.next) then
        self:_switch_to(self.next)
      end
      return
    end
    -- root to leaf for non Exit Hooks
    local tPath = {}
    repeat
      table.insert(tPath, tTo)
      tTo = tTo.parent
    until not tTo
    local l = #tPath
    for i = l, 1, -1 do
      local s = tPath[i]
      if s.obj[sHook] and s.obj[sHook](s.obj, self) then
        break
      end
    end
    if(self.next) then
      self:_switch_to(self.next)
    end
  end

  --[[
    Rise Event in the Hsm.M Instance calling Event hook in the hierarchy from current state
    event will be accessed from statemachine with e and data from edata.
    @param name : string
    @param eventData : will get accessed by statemachine.eData
  ]]
  function M:event(name, eventData)
    self.e = name
    self.eData = eventData
    local s = self.current
    repeat
      if s.obj.Event then
        self.working = s
        -- stop bubbling if return true
        if s.obj:Event(self) then
          if (self.next) then
            self.eData = nil
            self:_switch_to(self.next)
          end
          return true
        end
      end
      s = s.parent
      if not s then
        break
      end
    until false
    self.eData = nil
    if (self.next) then
      self:_switch_to(self.next)
    end
    return false
  end

  --[[
    Find the fist common ancestor bewteen s and target
  ]]
  function M:_find_common_ancestor(s, target)
    repeat
      do
        local t = target
        repeat
          do
            if s == t then
              return t
            end
            t = t.parent
          end
        until not t
        s = s.parent
      end
    until not s
    return nil
  end

  function M:switch_to(name)
    local target = self.model:get_state(name)
    if not target then
      return false
    end
    self.next = target
    return true
  end

  --[[
    Default state transition
    @param name : string
    @return : boolean true if transition is successful false if not
  ]]
  function M:_switch_to(target)
    self.next = nil
    local name = target.name
    local from = self.e == "Enter" and self.working or self.current
    local ancestor = from.commonAncestorsCache[name]
    if ancestor == nil then
      ancestor = self:_find_common_ancestor(from, target)
      --caching nil as -1 to properly cache it
      from.commonAncestorsCache[name] = ancestor or -1
    end
    -- To fix caching null as -1
    ancestor = ancestor == -1 and nil or ancestor
    if (ancestor ~= from) then
      self:h_call("Exit", ancestor, from)
    end
    
    self.current = target
    self:h_call("Enter", ancestor, target)
    self.working = target
  end

  --[[
    Exits, ReInitialize and Updates the current state
  ]]
  function M:restart_current()
    local o = self.current.obj
    self.working = self.current
    local _ = o.Exit and o:Exit(self)
    _ = o.Enter and o:Enter(self)
  end

  --[[
    Get the current state
  ]]
  function M:get_current()
    return self.current
  end

  --[[
    Exits from all the active states
  ]]
  function M:stop()
    print("Stopping the state machine")
    self:h_call("Exit", nil, self.current)
    self.current = nil
  end

  --[[
    Exits from all the active states
  ]]
  function M:update()
    self:h_call("Update", nil, self.current)
  end

  --[[
    Exits from all the active states
  ]]
  function M:is_running()
    return self.current ~= nil
  end

  --[[
    Check if the caller is the current state
  ]]
  function M:is_current()
    return self.current == self.working
  end
end

return Hsm
